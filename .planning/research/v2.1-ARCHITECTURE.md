# Architecture Research: v2.1 Enhancements

**Project:** The 55 Workshop Facilitation App
**Researched:** 2026-01-19
**Focus:** Integration architecture for v2.1 features

## Current Architecture Overview

### System Stack
- **Backend:** FastAPI (Python 3.13) with Uvicorn
- **Database:** SQLite with WAL mode, SQLAlchemy ORM
- **Templates:** Jinja2 server-rendered HTML
- **Frontend:** Vanilla JavaScript, no build step
- **Real-time:** Polling at 2.5-second intervals
- **AI:** Claude API via AsyncAnthropic, background tasks

### Current Component Boundaries

```
/var/www/the55/app/
  main.py              # FastAPI app, lifespan, router mounting
  config.py            # Pydantic settings from env
  dependencies.py      # Shared dependencies (auth, db)

  db/
    database.py        # Engine, SessionLocal, Base
    models.py          # Team, Member, Session, Response

  routers/
    auth.py            # Login/logout
    admin.py           # Dashboard
    teams.py           # Team CRUD
    members.py         # Member CRUD
    sessions.py        # Session state machine, synthesis trigger
    participant.py     # Public join flow
    images.py          # Image list API
    qr.py              # QR code generation

  services/
    synthesis.py       # Claude API integration

  schemas/
    __init__.py        # Pydantic models for synthesis

  templates/           # Jinja2 templates
  static/
    css/               # Stylesheets
    js/
      polling.js       # Real-time status updates
    images/55/         # 55 numbered SVG images (01.svg - 55.svg)
```

### Current Data Model

```
Team
  id, company_name, team_name, code, strategy_statement

Member
  id, team_id -> Team, name

Session
  id, team_id -> Team
  month (YYYY-MM), state (enum: draft/capturing/closed/revealed)
  synthesis_themes, synthesis_statements (JSON), synthesis_gap_type
  facilitator_notes, recalibration_action, recalibration_completed
  timestamps: created_at, closed_at, revealed_at

Response
  id, session_id -> Session, member_id -> Member
  image_number (1-55), bullets (JSON array)
  timestamps: submitted_at, updated_at
```

### Current Session State Machine

```
draft -> capturing -> closed -> revealed
         (start)     (close)   (reveal)
```

- **draft:** Session created, not yet open for participants
- **capturing:** Participants can join and submit responses
- **closed:** No more submissions, synthesis can be generated
- **revealed:** Results visible to participants

---

## Image Library Changes

### Current Implementation
- 55 static SVG images in `/static/images/55/`
- Sequential naming: `01.svg` to `55.svg`
- Images API endpoint: `GET /api/images` returns sorted list
- Participant browser shows 6 images per page (10 pages total)
- Images served directly via FastAPI StaticFiles mount

### v2.1 Requirements
- 200+ images auto-discovered from filesystem directory
- Images displayed in random order (different per session or page load)
- Pagination with ~20 images per page

### Architecture Recommendation

**File Discovery Service:**
```python
# app/services/images.py (new)
class ImageLibrary:
    """Discover and serve images from configurable directory."""

    def __init__(self, image_dir: Path):
        self._image_dir = image_dir
        self._cache: List[ImageInfo] = []
        self._cache_time: datetime = None

    def discover_images(self) -> List[ImageInfo]:
        """Scan directory for image files, cache results."""
        # Scan for .svg, .png, .jpg, .webp
        # Cache for 5 minutes (configurable)

    def get_randomized_order(self, seed: int) -> List[ImageInfo]:
        """Return images in deterministic random order for given seed."""
        # Use seed for reproducible shuffle per session
```

**Why file discovery over database:**
- Images are static assets, no metadata needed beyond filename
- Filesystem is the natural source of truth for images
- Adding/removing images is a file operation, not a database migration
- Caching avoids repeated filesystem scans

**Randomization Strategy:**
- **Per-session seed:** Use session_id as random seed for consistent ordering within a session
- **Deterministic shuffling:** `random.shuffle()` with seeded `random.Random(seed)`
- **Why session-scoped:** All participants in a session see same order, facilitator can reference "image on page 3" meaningfully

**Pagination Changes:**
```python
# API endpoint change
@router.get("/api/images")
async def list_images(
    page: int = 1,
    per_page: int = 20,
    seed: Optional[int] = None  # Session ID for consistent ordering
):
    images = image_library.get_randomized_order(seed or 0)
    start = (page - 1) * per_page
    return {
        "images": images[start:start + per_page],
        "total": len(images),
        "page": page,
        "per_page": per_page,
        "total_pages": ceil(len(images) / per_page)
    }
```

**Frontend Changes:**
- `respond.html` template receives `session.id` for seed parameter
- JavaScript pagination logic already exists, extend to fetch pages dynamically
- Consider: Load page 1 server-rendered, subsequent pages via AJAX

**Configuration Addition:**
```python
# config.py
class Settings(BaseSettings):
    # ... existing
    image_library_path: str = "static/images/library"  # v2.1 default
    images_per_page: int = 20
    image_cache_ttl: int = 300  # seconds
```

### Build Order for Image Library

1. **Create image service** (`services/images.py`)
2. **Update config** with new settings
3. **Modify images router** to use service, add pagination params
4. **Update participant respond template** for dynamic pagination
5. **Update JavaScript** for AJAX page loading
6. **Test with 200+ images**

---

## Session State Changes

### Current State Limitations
- Linear state machine: cannot go backwards
- No "reopen" capability once closed
- No ability to clear individual submissions while capturing

### v2.1 Requirements
- Session reopen: `revealed -> capturing` (to allow additional responses)
- Clear individual submission: Delete a member's response while capturing

### Architecture Recommendation

**State Transition Extension:**
```
                    reopen
                   +--------+
                   v        |
draft -> capturing -> closed -> revealed
         (start)     (close)   (reveal)
```

**New Endpoint: Reopen Session**
```python
# routers/sessions.py
@router.post("/{session_id}/reopen")
async def reopen_session(session_id: int, auth: AuthDep, db: DbDep):
    """Transition session from revealed back to capturing."""
    session = db.query(Session).filter(Session.id == session_id).first()

    if session.state not in (SessionState.CLOSED, SessionState.REVEALED):
        raise HTTPException(400, "Can only reopen closed or revealed sessions")

    session.state = SessionState.CAPTURING
    # Optionally: Clear synthesis to force re-generation
    # session.synthesis_themes = None
    # session.synthesis_statements = None
    db.commit()
```

**Design Decision: Preserve or Clear Synthesis?**
- **Preserve:** Old synthesis remains visible until new one generated
- **Clear:** Forces re-synthesis when closed again

Recommendation: **Preserve** - facilitator may just want one more response, synthesis is expensive to regenerate. Add explicit "Regenerate Synthesis" button if needed.

**New Endpoint: Clear Individual Response**
```python
@router.delete("/{session_id}/responses/{member_id}")
async def clear_response(
    session_id: int,
    member_id: int,
    auth: AuthDep,
    db: DbDep
):
    """Delete a member's response (facilitator action)."""
    session = db.query(Session).filter(Session.id == session_id).first()

    if session.state != SessionState.CAPTURING:
        raise HTTPException(400, "Can only clear responses while capturing")

    response = db.query(Response).filter(
        Response.session_id == session_id,
        Response.member_id == member_id
    ).first()

    if response:
        db.delete(response)
        db.commit()

    return {"status": "cleared", "member_id": member_id}
```

**UI Changes:**
- Session view: Add "Clear" button next to each submitted member
- Session view (revealed state): Add "Reopen Session" button
- Confirmation dialogs for destructive actions

### Build Order for Session State Changes

1. **Add reopen endpoint** to sessions router
2. **Add clear response endpoint** to sessions router
3. **Update session view template** with new buttons
4. **Add confirmation JavaScript** for destructive actions
5. **Test state transitions** exhaustively

---

## Presentation Mode Changes

### Current Implementation
- Single "present.html" template showing all synthesis at once
- Themes, gap type, attributed statements displayed together
- Designed for projector display (dark theme)

### v2.1 Requirements
Three presentation levels:
1. **Themes only:** High-level summary (anonymous, safe to show first)
2. **Attributed insights:** Statements with participant names
3. **Raw responses:** Full participant responses with images

### Architecture Recommendation

**Approach: Tab-based presentation view**

Rather than three separate pages, use a single page with tab navigation:

```python
# routers/sessions.py
@router.get("/{session_id}/present")
async def present_session(
    request: Request,
    session_id: int,
    auth: AuthDep,
    db: DbDep,
    level: str = "themes"  # themes, attributed, raw
):
    # ... existing code ...

    # For "raw" level, also load responses
    raw_responses = None
    if level == "raw":
        responses = db.query(Response).options(
            joinedload(Response.member)
        ).filter(Response.session_id == session_id).all()

        raw_responses = [{
            "member_name": r.member.name,
            "image_number": r.image_number,
            "image_url": f"/static/images/55/{r.image_number}.svg",
            "bullets": json.loads(r.bullets)
        } for r in responses]

    return templates.TemplateResponse(
        "admin/sessions/present.html",
        {
            # ... existing context ...
            "presentation_level": level,
            "raw_responses": raw_responses
        }
    )
```

**Template Structure:**
```html
<!-- present.html -->
<div class="presentation-tabs">
    <button class="tab {% if level == 'themes' %}active{% endif %}"
            onclick="location.href='?level=themes'">Themes</button>
    <button class="tab {% if level == 'attributed' %}active{% endif %}"
            onclick="location.href='?level=attributed'">Insights</button>
    <button class="tab {% if level == 'raw' %}active{% endif %}"
            onclick="location.href='?level=raw'">Responses</button>
</div>

{% if presentation_level == 'themes' %}
    <!-- Just synthesis_themes and gap_type -->
{% elif presentation_level == 'attributed' %}
    <!-- synthesis_statements with participants -->
{% elif presentation_level == 'raw' %}
    <!-- Full responses with images -->
{% endif %}
```

**Alternative: Keyboard navigation**
For live facilitation, tab navigation via arrow keys:
- Left/Right arrows cycle through levels
- No URL changes, pure JavaScript state
- Better for fluid presentation flow

Recommendation: **Implement both** - URL params for direct linking, keyboard for live navigation.

### Build Order for Presentation Mode

1. **Extend present endpoint** with level parameter
2. **Load raw responses** when level=raw
3. **Update present template** with tab navigation
4. **Add keyboard navigation JavaScript**
5. **Style each presentation level**

---

## Data Flow Diagram

### Current Flow
```
Participant Device          Server                    Database
       |                       |                         |
       |-- GET /join --------->|                         |
       |<-- join form ---------|                         |
       |-- POST code --------->|-- lookup team --------->|
       |<-- session select ----|<-- sessions ------------|
       |-- POST session ------>|                         |
       |<-- name select -------|                         |
       |-- POST name --------->|                         |
       |<-- strategy view -----|                         |
       |-- GET /respond ------>|-- load images --------->|
       |<-- image browser -----|<-- paginated images ----|
       |-- POST response ----->|-- save response ------->|
       |<-- waiting ------------|                         |
       |                       |                         |
       |== POLLING ============|== CHECK STATE =========|
       |                       |                         |
       |<-- synthesis (when revealed) -------------------|
```

### v2.1 Flow Changes

**Image loading becomes dynamic:**
```
       |-- GET /respond ------>|                         |
       |<-- page 1 SSR --------|                         |
       |                       |                         |
       |-- GET /api/images?page=2&seed=123 -->|          |
       |<-- images JSON -------|<-- from cache/filesystem|
```

**New facilitator actions:**
```
Facilitator Device          Server                    Database
       |                       |                         |
       |-- DELETE response --->|-- delete row --------->|
       |<-- 200 OK ------------|                         |
       |                       |                         |
       |-- POST /reopen ------>|-- update state -------->|
       |<-- redirect ----------|<-- session updated -----|
```

---

## Database Schema Changes

### Changes Required: NONE

The current schema supports all v2.1 features:

- **Image library:** No schema impact (filesystem-based)
- **Random ordering:** Computed at runtime using session_id as seed
- **Session reopen:** State enum already supports transition back
- **Clear responses:** Response table supports deletion
- **Three-level presentation:** Synthesis data already stored, raw responses queryable

The only consideration is whether to add:

```sql
-- Optional: Track presentation level preference per session
ALTER TABLE sessions ADD COLUMN presentation_level VARCHAR(20) DEFAULT 'themes';
```

Recommendation: **Skip for now.** Presentation level is a view concern, not persistent state. Query parameter is sufficient.

---

## Component Integration Summary

### New Files
```
app/services/images.py     # Image library discovery and caching
```

### Modified Files
```
app/config.py              # Add image library settings
app/routers/images.py      # Pagination, seed parameter
app/routers/sessions.py    # reopen, clear_response endpoints
app/templates/
  participant/respond.html # Dynamic pagination JavaScript
  admin/sessions/view.html # Reopen button, clear response buttons
  admin/sessions/present.html # Three-level tabs, keyboard nav
app/static/js/
  respond.js (new or inline) # AJAX image pagination
  present.js (new or inline) # Keyboard navigation for presentation
```

### Configuration Changes
```
.env (new variables):
  IMAGE_LIBRARY_PATH=/var/www/the55/app/static/images/library
  IMAGES_PER_PAGE=20
  IMAGE_CACHE_TTL=300
```

---

## Suggested Build Order

Based on dependencies between components:

### Phase 1: Image Library Foundation
1. Create `services/images.py` with ImageLibrary class
2. Update `config.py` with image settings
3. Modify `routers/images.py` for pagination and seed
4. **Test:** API returns paginated, seeded images

### Phase 2: Participant Image Browser
5. Update `respond.html` template for dynamic pagination
6. Add JavaScript for AJAX page loading
7. **Test:** Participant can browse 200+ images

### Phase 3: Session State Extensions
8. Add `POST /sessions/{id}/reopen` endpoint
9. Add `DELETE /sessions/{id}/responses/{member_id}` endpoint
10. Update `sessions/view.html` with new controls
11. **Test:** Full state cycle including reopen

### Phase 4: Presentation Levels
12. Extend `present` endpoint with level parameter
13. Update `present.html` with tab navigation
14. Add keyboard navigation JavaScript
15. Load raw responses for level=raw
16. **Test:** All three levels work, keyboard nav functional

### Phase 5: Integration Testing
17. End-to-end: Create session, capture, close, present at each level
18. Edge cases: Reopen after synthesis, clear last response, etc.

---

## Risk Areas

### Image Library Performance
- **Risk:** 200+ images on filesystem scan could be slow
- **Mitigation:** Cache discovery results with TTL, load incrementally

### Polling During Reopen
- **Risk:** Participants on waiting screen when session reopens
- **Mitigation:** Polling already handles state changes, redirects appropriately

### Presentation Mode State
- **Risk:** Facilitator loses place when switching tabs
- **Mitigation:** Keyboard nav avoids page reload, URL params preserve state on refresh

### Synthesis Regeneration
- **Risk:** Unclear when to regenerate synthesis after reopen
- **Mitigation:** Explicit "Regenerate" button rather than automatic

---

*Architecture research: 2026-01-19*
*Confidence: HIGH - based on direct codebase analysis*
