# Stack Research: v2.1 Enhancements

**Project:** The 55 Workshop Facilitation App
**Researched:** 2026-01-19
**Scope:** Image gallery pagination, real-time UX, structured AI presentation

## Current Stack

The app already has everything needed. **No new dependencies required.**

| Technology | Version | Purpose |
|------------|---------|---------|
| FastAPI | 0.128.0 | Backend framework with async support |
| SQLAlchemy | 2.0.36 | Database ORM |
| SQLite | (system) | Data storage |
| Jinja2 | 3.1.6 | Server-side templating |
| Uvicorn | 0.40.0 | ASGI server |
| Anthropic | 0.76.0 | Claude API client |
| qrcode[pil] | 8.2 | QR code generation (already installed) |
| Vanilla JS | ES6+ | Client-side interactivity |

**Key constraint:** No build step, no npm, no frameworks. ES6+ vanilla JavaScript only.

## Recommended Additions

**None.** The current stack supports all v2.1 features.

The existing `qrcode[pil]==8.2` library already supports:
- PNG generation to BytesIO buffer
- Base64 encoding via `png_as_base64_str()` or manual encoding
- Custom sizing and error correction levels

The existing `anthropic==0.76.0` library supports:
- Structured outputs (JSON schema mode) via beta header
- Tool use for schema-guaranteed responses

## Patterns to Use

### 1. Image Gallery with Sticky Navigation

**Pattern:** CSS `position: sticky` with vendor prefix + scroll container architecture

```css
/* Sticky header that works on mobile Safari */
.gallery-header {
    position: -webkit-sticky; /* Safari */
    position: sticky;
    top: 0;
    z-index: 10;
    background: var(--color-bg);
}
```

**Critical requirements for mobile Safari:**
- Add `-webkit-sticky` vendor prefix for Safari 13 and below
- Ensure no parent has `overflow: hidden` (breaks sticky context)
- Avoid `position: absolute` containers around sticky elements
- Use `top: 0` to trigger sticky behavior at viewport top

**HTML structure:**
```html
<div class="gallery-container">
    <!-- Sticky header with instructions + pagination -->
    <div class="gallery-header">
        <p class="instruction">Select an image that best describes...</p>
        <div class="pagination">Page 1 of 10 | Prev | Next</div>
    </div>

    <!-- Scrollable image grid -->
    <div class="image-grid">
        <!-- Images scroll under the sticky header -->
    </div>
</div>
```

**Why this pattern:**
- Pure CSS, no JavaScript scroll listeners needed
- Hardware-accelerated by GPU
- Works on all target browsers (Chrome, Safari, Firefox, Samsung Internet)
- Existing codebase already uses similar card/header patterns

### 2. Random Image Order (Fisher-Yates Shuffle)

**Pattern:** Server-side shuffle on page load, not client-side

```python
# In FastAPI route
import random

def get_shuffled_images(image_dir: Path) -> list[int]:
    """Auto-discover images and return shuffled order."""
    images = sorted([
        int(f.stem) for f in image_dir.glob("*.svg")
        if f.stem.isdigit()
    ])
    random.shuffle(images)  # Fisher-Yates in-place
    return images
```

**Why server-side:**
- Shuffle happens once per page load (not on every pagination click)
- Template receives pre-shuffled list, client just paginates through it
- Consistent ordering during session (user doesn't see different images on Back)
- No client-side array manipulation needed

**Client-side pagination:**
```javascript
// Image order comes from server as shuffled array
const imageOrder = {{ shuffled_images|tojson }};
const IMAGES_PER_PAGE = 20;
let currentPage = 0;

function showPage(pageNum) {
    const start = pageNum * IMAGES_PER_PAGE;
    const end = start + IMAGES_PER_PAGE;
    const pageImages = imageOrder.slice(start, end);
    // Render pageImages...
}
```

### 3. Auto-Discovery of Images

**Pattern:** Directory scanning at runtime, no hardcoded counts

```python
from pathlib import Path

def discover_images(static_dir: Path) -> list[dict]:
    """Scan directory for images, return metadata."""
    image_dir = static_dir / "images" / "55"
    images = []

    for path in sorted(image_dir.glob("*")):
        if path.suffix.lower() in {".svg", ".png", ".jpg", ".webp"}:
            images.append({
                "filename": path.name,
                "id": path.stem,  # filename without extension
                "path": f"/static/images/55/{path.name}"
            })

    return images
```

**Why this pattern:**
- Dale can add/remove images without code changes
- Supports mixed formats (SVG, PNG, JPG)
- Descriptive filenames preserved
- Image count determined at runtime

### 4. Real-Time Status Display

**Pattern:** Keep existing polling (2.5s interval), enhance display

The current `polling.js` implementation is appropriate for the use case:
- 25 users maximum
- 2.5 second refresh is adequate for "who has submitted" feedback
- Simple, reliable, no WebSocket infrastructure needed

**Enhancement for combined QR + status screen:**
```javascript
// Existing polling pattern, add QR visibility
async function pollStatus() {
    const response = await fetch(`/admin/sessions/${sessionId}/status`);
    const data = await response.json();

    // Update submission counts
    updateSubmissionDisplay(data);

    // QR code is static, already rendered server-side
    // No polling needed for QR
}
```

**Why NOT use SSE or WebSockets:**
- Current polling works reliably
- 25 concurrent users is well within polling's sweet spot
- SSE would require connection management for minimal benefit
- WebSockets add infrastructure complexity (nginx config, reconnection logic)
- "If it ain't broke, don't fix it"

### 5. QR Code Generation

**Pattern:** Server-side generation, embed as base64 data URI

```python
import qrcode
import io
import base64

def generate_qr_base64(url: str, box_size: int = 10) -> str:
    """Generate QR code and return as base64 data URI."""
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_M,
        box_size=box_size,
        border=4,
    )
    qr.add_data(url)
    qr.make(fit=True)

    img = qr.make_image(fill_color="black", back_color="white")

    buffer = io.BytesIO()
    img.save(buffer, format="PNG")
    b64 = base64.b64encode(buffer.getvalue()).decode()

    return f"data:image/png;base64,{b64}"
```

**Template usage:**
```html
<img src="{{ qr_data_uri }}" alt="QR code to join session" class="qr-code">
```

**Why base64 data URI:**
- Single HTTP response, no separate image request
- Works offline (cached in page)
- No file system operations
- Current `qrcode[pil]==8.2` already installed

### 6. Session Flow Controls

**Pattern:** State machine with explicit transitions

Current states: `draft -> capturing -> closed -> revealed`

**Add new transitions:**
```
capturing -> closed (existing: close capture)
closed -> capturing (new: reopen capture)
closed -> closed (new: clear individual submission)
```

**API endpoints:**
```python
@router.post("/sessions/{session_id}/reopen")
async def reopen_capture(session_id: int):
    """Reopen session from closed back to capturing."""
    session = get_session(session_id)
    if session.state != SessionState.closed:
        raise HTTPException(400, "Can only reopen closed sessions")
    session.state = SessionState.capturing
    db.commit()

@router.post("/sessions/{session_id}/clear-submission/{member_id}")
async def clear_submission(session_id: int, member_id: int):
    """Clear a member's submission so they can resubmit."""
    # Delete response record, member can submit again
```

### 7. Structured AI Synthesis Presentation

**Pattern:** Three-level data structure, progressive reveal

```python
# Data model for synthesis output
class SynthesisOutput:
    level_1_themes: str           # High-level synthesis (AI-generated)
    level_2_grouped: list[dict]   # Attributed grouped insights (AI-generated)
    level_3_raw: list[dict]       # Raw statements by person (data, no AI)
```

**Level structure:**
1. **Themes** (AI): "The team is grappling with unclear priorities and communication gaps..."
2. **Grouped Insights** (AI): Similar ideas clustered with participant names
3. **Raw Statements** (Data): Every bullet point, attributed, no AI processing

**UI Pattern: Tab navigation**
```html
<div class="presentation-levels" role="tablist">
    <button role="tab" aria-selected="true" aria-controls="level-1">Themes</button>
    <button role="tab" aria-controls="level-2">Grouped Insights</button>
    <button role="tab" aria-controls="level-3">Raw Statements</button>
</div>

<div id="level-1" role="tabpanel">{{ themes }}</div>
<div id="level-2" role="tabpanel" hidden>{{ grouped_insights }}</div>
<div id="level-3" role="tabpanel" hidden>{{ raw_statements }}</div>
```

**Accessibility requirements:**
- `role="tab"` and `role="tabpanel"` for screen readers
- `aria-selected` tracks active tab
- `aria-controls` links tab to panel
- Keyboard navigation (arrow keys between tabs)

### 8. Claude API Structured Output

**Pattern:** Use JSON schema mode for guaranteed structure

```python
from anthropic import Anthropic

client = Anthropic()

# Define schema for synthesis output
schema = {
    "type": "object",
    "properties": {
        "themes": {"type": "string"},
        "gap_type": {"type": "string", "enum": ["Direction", "Alignment", "Commitment"]},
        "grouped_insights": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "insight": {"type": "string"},
                    "participants": {"type": "array", "items": {"type": "string"}}
                }
            }
        }
    },
    "required": ["themes", "gap_type", "grouped_insights"]
}

response = client.messages.create(
    model="claude-sonnet-4-5-20251101",
    max_tokens=2000,
    extra_headers={"anthropic-beta": "structured-outputs-2025-11-13"},
    messages=[{"role": "user", "content": prompt}],
    output_format={
        "type": "json_schema",
        "json_schema": schema
    }
)

# response.content[0].text is guaranteed valid JSON matching schema
```

**Note:** Structured outputs require `anthropic-beta` header and work with Claude Sonnet 4.5 and Opus 4.1. Check current model availability at API call time.

## What NOT to Use

### DO NOT Add: React, Vue, or Any Framework

**Why not:**
- Project constraint: "ES6+ vanilla JS (no build step)"
- Current codebase is server-rendered Jinja2 + vanilla JS
- Pagination, tabs, polling are all achievable without frameworks
- Adding React would require build tooling, npm, bundlers
- Maintenance burden for simple interactions

### DO NOT Add: WebSockets or SSE

**Why not:**
- Current polling (2.5s) works for 25-user sessions
- WebSockets require nginx configuration changes
- SSE requires connection management
- Complexity outweighs benefit at this scale
- "Good enough" is good enough

### DO NOT Add: JavaScript Libraries (Lodash, jQuery, etc.)

**Why not:**
- Fisher-Yates shuffle is 4 lines of code
- `fetch` API is native
- Array methods (`slice`, `forEach`) are native ES6+
- No library provides meaningful value for these features

### DO NOT Add: CSS Frameworks (Tailwind, Bootstrap)

**Why not:**
- Existing `main.css` has established design system
- CSS variables for spacing, colors, fonts
- Tailwind would require build step
- Bootstrap conflicts with existing styles

### DO NOT Add: External QR Libraries

**Why not:**
- `qrcode[pil]==8.2` already installed
- Does everything needed (PNG, base64, sizing)
- No CDN dependency for client-side generation

### DO NOT Add: Database Migrations (Alembic)

**Why not:**
- SQLite file is portable
- Schema changes are rare
- Manual SQL scripts sufficient for v2.1 changes
- Add migration tooling when there's actual pain

## Implementation Notes

### Sticky Navigation Browser Compatibility

| Browser | Support | Notes |
|---------|---------|-------|
| Chrome 91+ | Full | No prefix needed |
| Safari 13+ | Full | Requires `-webkit-sticky` prefix |
| Firefox 59+ | Full | No prefix needed |
| Samsung Internet 7.0+ | Full | Based on Chromium |
| iOS Safari | Full | With `-webkit-sticky` and proper parent structure |

**Testing requirement:** Verify sticky behavior on actual iOS Safari device, not just Chrome DevTools mobile simulation.

### Image Library Scaling

Current: 55 images (SVG, ~500 bytes each)
Target: 200+ images

**Performance considerations:**
- SVGs are tiny, no lazy loading needed for thumbnails
- 20 images per page = 10 pages maximum
- Each image is ~500 bytes = 10KB per page
- No performance concern at this scale

**If using larger images (PNG/JPG):**
- Add `loading="lazy"` to images not on first page
- Consider thumbnail generation (not needed for v2.1)

### QR Code Sizing

**Recommended sizes:**
- Projection display: 300x300px minimum
- Mobile scan distance: 200x200px at arm's length
- Print: 1 inch minimum at 300 DPI

**Error correction levels:**
- L (7%): Smallest QR, lowest damage tolerance
- M (15%): Good balance, recommended
- Q (25%): Higher density, more damage tolerance
- H (30%): Highest density, best for logos/damage

Use `ERROR_CORRECT_M` for session URLs (short, simple data).

### Session State Machine Updates

```
Current states and transitions:

  draft ──start──> capturing ──close──> closed ──reveal──> revealed
                       ^                   │
                       │                   │
                       └─────reopen────────┘
                                           │
                                           └──clear_submission──> (same state)
```

**State invariants:**
- `draft`: No responses accepted
- `capturing`: Responses accepted, editable
- `closed`: No new responses, synthesis can run
- `revealed`: Results visible to participants

**New operations:**
- `reopen`: closed -> capturing (for latecomers)
- `clear_submission`: Deletes one member's response (any time before revealed)

### Synthesis Data Structure

```python
# Store as JSON in session record
synthesis_data = {
    "version": 1,
    "generated_at": "2026-01-19T10:30:00Z",
    "model": "claude-sonnet-4-5-20251101",

    # Level 1: AI-generated themes
    "themes": "The team is navigating uncertainty about...",

    # Level 2: AI-generated grouped insights
    "grouped_insights": [
        {
            "insight": "Concern about resource allocation",
            "participants": ["Alice", "Bob"]
        },
        {
            "insight": "Excitement about new direction",
            "participants": ["Carol", "Dave"]
        }
    ],

    # Level 3: Raw data (no AI)
    "raw_statements": [
        {
            "member_name": "Alice",
            "image_number": 23,
            "bullets": ["We're stretched thin", "Need clearer priorities"]
        }
    ],

    # Gap type classification
    "gap_type": "Alignment"
}
```

### Export Formats

**Per-level JSON exports:**
```
/admin/sessions/{id}/export/themes     -> { themes, gap_type }
/admin/sessions/{id}/export/grouped    -> { grouped_insights }
/admin/sessions/{id}/export/raw        -> { raw_statements }
/admin/sessions/{id}/export/full       -> { all levels }
```

## Sources

**Sticky Navigation:**
- [CSS Position Sticky - How It Really Works](https://elad.medium.com/css-position-sticky-how-it-really-works-54cd01dc2d46)
- [Why CSS Position Sticky is Not Working | BrowserStack](https://www.browserstack.com/guide/why-css-position-sticky-is-not-working)
- [How to Fix CSS position: sticky Not Working on Mobile | codestudy.net](https://www.codestudy.net/blog/how-to-enable-css-position-sticky-in-mobile-browsers/)

**Fisher-Yates Shuffle:**
- [Fisher-Yates Shuffle | bost.ocks.org](https://bost.ocks.org/mike/shuffle/)
- [How to shuffle an array with vanilla JS | Go Make Things](https://gomakethings.com/how-to-shuffle-an-array-with-vanilla-js/)

**Real-Time Updates:**
- [SSE vs Polling vs WebSockets | fictionally-irrelevant](https://fictionally-irrelevant.vercel.app/posts/why-you-should-use-server-side-events-over-web-sockets-and-long-polling)
- [FastAPI SSE Implementation | Medium](https://mahdijafaridev.medium.com/implementing-server-sent-events-sse-with-fastapi-real-time-updates-made-simple-6492f8bfc154)

**QR Code Generation:**
- [qrcode-fastapi | GitHub](https://github.com/nessshon/qrcode-fastapi)
- [Generate QR Code using qrcode in Python | GeeksforGeeks](https://www.geeksforgeeks.org/python/generate-qr-code-using-qrcode-in-python/)

**Claude Structured Outputs:**
- [Structured outputs - Claude Docs](https://platform.claude.com/docs/en/build-with-claude/structured-outputs)
- [Hands-On Guide to Anthropic's Structured Output | Towards Data Science](https://towardsdatascience.com/hands-on-with-anthropics-new-structured-output-capabilities/)

**Accessible Tabs:**
- [ARIA: tab role | MDN](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Roles/tab_role)
- [Building accessible UI tabs in JavaScript | LogRocket](https://blog.logrocket.com/build-accessible-user-interface-tabs-javascript/)
