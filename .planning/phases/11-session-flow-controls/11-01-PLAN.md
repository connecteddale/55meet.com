---
phase: 20-session-flow-controls
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - /var/www/the55/app/routers/sessions.py
autonomous: true

must_haves:
  truths:
    - "POST /admin/sessions/{id}/reopen transitions CLOSED to CAPTURING"
    - "POST /admin/sessions/{id}/member/{mid}/clear deletes submission"
    - "Reopen clears synthesis data (themes, statements, gap_type)"
    - "Clear only works during CAPTURING state"
  artifacts:
    - path: "/var/www/the55/app/routers/sessions.py"
      provides: "reopen_capture and clear_member_submission endpoints"
      contains: "def reopen_capture"
  key_links:
    - from: "reopen_capture"
      to: "SessionState.CAPTURING"
      via: "state transition with synthesis cleanup"
      pattern: "session\\.state = SessionState\\.CAPTURING"
---

<objective>
Add backend endpoints for session flow control (reopen capture and clear submission).

Purpose: Enable facilitators to manage real-world session dynamics via API endpoints.
Output: Two new POST endpoints in sessions.py router.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-session-flow-controls/20-RESEARCH.md

Existing router patterns:
@/var/www/the55/app/routers/sessions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reopen_capture endpoint</name>
  <files>/var/www/the55/app/routers/sessions.py</files>
  <action>
Add new endpoint after close_capture (around line 224):

```python
@router.post("/{session_id}/reopen")
async def reopen_capture(session_id: int, auth: AuthDep, db: DbDep):
    """Transition session from closed to capturing (for latecomers)."""
    session = db.query(Session).filter(Session.id == session_id).first()
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")

    if session.state != SessionState.CLOSED:
        raise HTTPException(
            status_code=400,
            detail=f"Cannot reopen. Session is in '{session.state.value}' state."
        )

    # Clear synthesis data (will need regeneration)
    session.synthesis_themes = None
    session.synthesis_statements = None
    session.synthesis_gap_type = None

    session.state = SessionState.CAPTURING
    session.closed_at = None  # Reset close timestamp
    db.commit()

    return RedirectResponse(url=f"/admin/sessions/{session_id}", status_code=303)
```

Follow existing pattern from close_capture: state validation, HTTPException on invalid state, RedirectResponse on success.
  </action>
  <verify>
Server still starts: `cd /var/www/the55 && source venv/bin/activate && python -c "from app.routers.sessions import router; print('OK')"`
  </verify>
  <done>reopen_capture endpoint exists and validates state transition from CLOSED to CAPTURING</done>
</task>

<task type="auto">
  <name>Task 2: Add clear_member_submission endpoint</name>
  <files>/var/www/the55/app/routers/sessions.py</files>
  <action>
Add new endpoint after reopen_capture:

```python
@router.post("/{session_id}/member/{member_id}/clear")
async def clear_member_submission(
    session_id: int,
    member_id: int,
    auth: AuthDep,
    db: DbDep
):
    """Clear a specific participant's submission to allow resubmit."""
    session = db.query(Session).filter(Session.id == session_id).first()
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")

    # Only allow clearing during CAPTURING state
    if session.state != SessionState.CAPTURING:
        raise HTTPException(
            status_code=400,
            detail="Can only clear submissions while capturing."
        )

    # Delete the response (hard delete, no audit trail needed)
    response = db.query(Response).filter(
        Response.session_id == session_id,
        Response.member_id == member_id
    ).first()

    if not response:
        raise HTTPException(status_code=404, detail="No submission found")

    db.delete(response)
    db.commit()

    return RedirectResponse(url=f"/admin/sessions/{session_id}", status_code=303)
```

Follow existing query pattern from get_session_status for member/response lookups.
  </action>
  <verify>
Server still starts: `cd /var/www/the55 && source venv/bin/activate && python -c "from app.routers.sessions import router; print('OK')"`
  </verify>
  <done>clear_member_submission endpoint exists and deletes specific member's response during CAPTURING state</done>
</task>

</tasks>

<verification>
1. Module imports successfully:
   ```bash
   cd /var/www/the55 && source venv/bin/activate && python -c "from app.routers.sessions import reopen_capture, clear_member_submission; print('OK')"
   ```

2. Both functions have correct decorators:
   ```bash
   grep -n "router.post.*reopen\|router.post.*clear" /var/www/the55/app/routers/sessions.py
   ```
</verification>

<success_criteria>
- Two new POST endpoints added to sessions.py
- reopen_capture: CLOSED -> CAPTURING with synthesis cleanup
- clear_member_submission: Deletes member response during CAPTURING
- Both return RedirectResponse(303) on success
- Both raise HTTPException(400) on invalid state
</success_criteria>

<output>
After completion, create `.planning/phases/20-session-flow-controls/20-01-SUMMARY.md`
</output>
