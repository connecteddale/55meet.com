---
phase: 17-integration-deploy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - /etc/systemd/system/the55.service
  - the55/scripts/check_service.sh
autonomous: true

must_haves:
  truths:
    - "The 55 app starts automatically on server boot"
    - "The 55 app restarts automatically if it crashes"
    - "Gunicorn runs with uvicorn workers for async support"
    - "App runs on port 8055 for nginx reverse proxy"
  artifacts:
    - path: "/etc/systemd/system/the55.service"
      provides: "systemd service unit for process management"
      contains: "gunicorn.*uvicorn"
    - path: "the55/scripts/check_service.sh"
      provides: "Health check script for verification"
      contains: "systemctl status"
  key_links:
    - from: "/etc/systemd/system/the55.service"
      to: "/var/www/the55/venv/bin/gunicorn"
      via: "ExecStart command"
      pattern: "ExecStart=.*gunicorn"
    - from: "the55.service"
      to: "app.main:app"
      via: "ASGI app reference"
      pattern: "app\\.main:app"
---

<objective>
Configure systemd service for The 55 app with gunicorn + uvicorn workers.

Purpose: Production apps need process management for auto-restart, boot startup, and logging. The existing server uses systemd for Flask apps (gg.service, gunicorn.service). The 55 uses FastAPI which requires uvicorn workers for async support.

Output:
- systemd service file at /etc/systemd/system/the55.service
- Service running on port 8055 (distinct from existing 5000, 5001)
- Verification script to confirm service health
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Existing patterns
@/etc/systemd/system/gg.service
@/etc/systemd/system/gunicorn.service

# App structure
@the55/app/main.py
@the55/requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create systemd service file</name>
  <files>/etc/systemd/system/the55.service</files>
  <action>
Create systemd service file for The 55 app:

```ini
[Unit]
Description=The 55 - Leadership Alignment Diagnostics (FastAPI)
After=network.target

[Service]
User=DrPloy
Group=www-data
WorkingDirectory=/var/www/the55
Environment="PATH=/var/www/the55/venv/bin"
ExecStart=/var/www/the55/venv/bin/gunicorn app.main:app \
    --workers 2 \
    --worker-class uvicorn.workers.UvicornWorker \
    --bind 127.0.0.1:8055 \
    --access-logfile /var/www/the55/logs/access.log \
    --error-logfile /var/www/the55/logs/error.log
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

Key differences from Flask gunicorn.service:
- Uses `--worker-class uvicorn.workers.UvicornWorker` for async FastAPI support
- Binds to port 8055 (not 5000/5001 which are used by existing services)
- Logs to the55's logs directory
- 2 workers sufficient for single facilitator + 25 participants

After creating the file, run:
```bash
sudo systemctl daemon-reload
sudo systemctl enable the55
sudo systemctl start the55
sudo systemctl status the55
```
  </action>
  <verify>
```bash
sudo systemctl status the55 | head -20
```
Expected: Active (running) status
  </verify>
  <done>systemd service the55.service exists, is enabled, and running on port 8055</done>
</task>

<task type="auto">
  <name>Task 2: Create health check script</name>
  <files>the55/scripts/check_service.sh</files>
  <action>
Create a health check script for verifying service operation:

```bash
#!/bin/bash
# check_service.sh - Verify The 55 service is running correctly

set -e

echo "=== The 55 Service Health Check ==="
echo ""

# Check systemd status
echo "1. Systemd Status:"
systemctl is-active the55 && echo "   Service: ACTIVE" || echo "   Service: INACTIVE"

# Check process
echo ""
echo "2. Process Check:"
pgrep -f "gunicorn.*the55" > /dev/null && echo "   Gunicorn: RUNNING" || echo "   Gunicorn: NOT FOUND"

# Check port binding
echo ""
echo "3. Port Check:"
ss -tlnp | grep :8055 > /dev/null && echo "   Port 8055: LISTENING" || echo "   Port 8055: NOT LISTENING"

# Check health endpoint
echo ""
echo "4. Health Endpoint:"
curl -s http://127.0.0.1:8055/health | grep -q "ok" && echo "   /health: OK" || echo "   /health: FAILED"

echo ""
echo "=== Check Complete ==="
```

Make executable:
```bash
chmod +x /var/www/the55/scripts/check_service.sh
```
  </action>
  <verify>
```bash
/var/www/the55/scripts/check_service.sh
```
Expected: All 4 checks pass (ACTIVE, RUNNING, LISTENING, OK)
  </verify>
  <done>Health check script exists and reports service status correctly</done>
</task>

</tasks>

<verification>
1. `systemctl status the55` shows active (running)
2. `curl http://127.0.0.1:8055/health` returns `{"status":"ok"}`
3. `curl http://127.0.0.1:8055/login` returns HTML (login page)
4. After `sudo systemctl restart the55`, service recovers within 5 seconds
5. Logs appear in `/var/www/the55/logs/access.log` and `error.log`
</verification>

<success_criteria>
- The 55 app runs via gunicorn with uvicorn workers
- Service auto-starts on boot (enabled)
- Service auto-restarts on crash
- Health check script confirms all components functional
</success_criteria>

<output>
After completion, create `.planning/phases/17-integration-deploy/17-01-SUMMARY.md`
</output>
