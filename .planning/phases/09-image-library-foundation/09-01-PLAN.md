---
phase: 18-image-library-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - the55/app/config.py
  - the55/app/services/images.py
  - the55/app/routers/images.py
  - the55/app/routers/participant.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Images are discovered from filesystem directory at runtime"
    - "Adding/removing images requires no code changes"
    - "Image order is randomized using session ID as seed"
    - "Same session ID produces same image order on every request"
    - "API returns paginated images with total count and page info"
  artifacts:
    - path: "the55/app/services/images.py"
      provides: "ImageLibrary class with discovery and caching"
      exports: ["ImageLibrary", "get_image_library"]
      min_lines: 50
    - path: "the55/app/config.py"
      provides: "Image library configuration settings"
      contains: "image_library_path"
    - path: "the55/app/routers/images.py"
      provides: "Paginated image API with seed parameter"
      exports: ["router"]
  key_links:
    - from: "the55/app/routers/images.py"
      to: "the55/app/services/images.py"
      via: "Dependency injection get_image_library"
      pattern: "get_image_library"
    - from: "the55/app/routers/participant.py"
      to: "the55/app/services/images.py"
      via: "ImageLibrary for generating image pages"
      pattern: "image_library"
---

<objective>
Create image discovery service with session-seeded randomization for 200+ images.

Purpose: Enable the image library to support 200+ images with auto-discovery from the filesystem. Dale can add/remove images without code changes. Each session sees a consistent random order.

Output: Image service with caching, updated config, and enhanced API endpoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/v2.1-ARCHITECTURE.md
@.planning/research/v2.1-STACK.md

# Existing files to modify
@the55/app/config.py
@the55/app/routers/images.py
@the55/app/routers/participant.py
@the55/app/services/synthesis.py (for service pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Image Library Service</name>
  <files>the55/app/services/images.py, the55/app/config.py</files>
  <action>
Create `app/services/images.py` with ImageLibrary class:

```python
"""
The 55 App - Image Library Service

Auto-discovery of images from filesystem with caching and session-seeded randomization.
"""

import random
from datetime import datetime, timedelta
from pathlib import Path
from typing import List, Optional
from functools import lru_cache

from pydantic import BaseModel

from app.config import get_settings


class ImageInfo(BaseModel):
    """Image metadata."""
    id: str           # filename without extension
    filename: str     # full filename
    url: str          # URL path for serving


class ImageLibrary:
    """
    Discover and serve images from configurable directory.

    Features:
    - Auto-discovery of .svg, .png, .jpg, .webp files
    - Caching with configurable TTL (default 5 minutes)
    - Session-seeded randomization for consistent ordering
    """

    def __init__(self, image_dir: Path, cache_ttl_seconds: int = 300):
        self._image_dir = image_dir
        self._cache_ttl = cache_ttl_seconds
        self._cache: List[ImageInfo] = []
        self._cache_time: Optional[datetime] = None

    def _is_cache_valid(self) -> bool:
        """Check if cache is still valid."""
        if not self._cache_time:
            return False
        return datetime.now() - self._cache_time < timedelta(seconds=self._cache_ttl)

    def discover_images(self) -> List[ImageInfo]:
        """
        Scan directory for image files, cache results.

        Returns sorted list of ImageInfo objects.
        """
        if self._is_cache_valid():
            return self._cache

        images = []
        extensions = {'.svg', '.png', '.jpg', '.jpeg', '.webp'}

        if self._image_dir.exists():
            for path in sorted(self._image_dir.iterdir()):
                if path.suffix.lower() in extensions:
                    images.append(ImageInfo(
                        id=path.stem,
                        filename=path.name,
                        url=f"/static/images/library/{path.name}"
                    ))

        self._cache = images
        self._cache_time = datetime.now()
        return images

    def get_shuffled_images(self, seed: int) -> List[ImageInfo]:
        """
        Return images in deterministic random order for given seed.

        Uses Fisher-Yates shuffle with seeded random for reproducibility.
        Same seed always produces same order.

        Args:
            seed: Integer seed (typically session_id)

        Returns:
            List of ImageInfo in shuffled order
        """
        images = self.discover_images().copy()
        rng = random.Random(seed)
        rng.shuffle(images)
        return images

    def get_paginated_images(
        self,
        seed: int,
        page: int = 1,
        per_page: int = 20
    ) -> dict:
        """
        Return paginated images with metadata.

        Args:
            seed: Integer seed for randomization
            page: Page number (1-indexed)
            per_page: Images per page

        Returns:
            Dict with images, total, page, per_page, total_pages
        """
        all_images = self.get_shuffled_images(seed)
        total = len(all_images)
        total_pages = (total + per_page - 1) // per_page  # ceiling division

        # Clamp page to valid range
        page = max(1, min(page, total_pages)) if total_pages > 0 else 1

        start = (page - 1) * per_page
        end = start + per_page

        return {
            "images": all_images[start:end],
            "total": total,
            "page": page,
            "per_page": per_page,
            "total_pages": total_pages
        }

    @property
    def count(self) -> int:
        """Get total number of images."""
        return len(self.discover_images())


# Singleton instance (lazy initialization)
_image_library: Optional[ImageLibrary] = None


def get_image_library() -> ImageLibrary:
    """
    Get or create the image library singleton.

    Uses settings from config for path and TTL.
    """
    global _image_library
    if _image_library is None:
        settings = get_settings()
        image_dir = Path(settings.image_library_path)
        _image_library = ImageLibrary(
            image_dir=image_dir,
            cache_ttl_seconds=settings.image_cache_ttl
        )
    return _image_library
```

Update `app/config.py` to add image library settings:

```python
# Add these fields to the Settings class:

    # Image Library
    image_library_path: str = "app/static/images/library"  # Directory containing images
    images_per_page: int = 20  # Images per page in browser
    image_cache_ttl: int = 300  # Cache TTL in seconds (5 minutes)
```

Also add a cached settings getter if not present:

```python
from functools import lru_cache

@lru_cache
def get_settings() -> Settings:
    """Get cached settings instance."""
    return Settings()
```

Create the library directory:
```bash
mkdir -p /var/www/the55/app/static/images/library
```

For initial testing, copy the existing 55 images to the library directory (or create a symlink).
  </action>
  <verify>
```bash
cd /var/www/the55
python -c "
from app.services.images import get_image_library, ImageLibrary
from pathlib import Path

# Test with existing 55 images directory
lib = ImageLibrary(Path('app/static/images/55'))
images = lib.discover_images()
print(f'Discovered {len(images)} images')

# Test shuffling consistency
seed = 12345
order1 = [img.id for img in lib.get_shuffled_images(seed)]
order2 = [img.id for img in lib.get_shuffled_images(seed)]
assert order1 == order2, 'Shuffle not consistent!'
print('Shuffle consistency: OK')

# Test pagination
page = lib.get_paginated_images(seed, page=1, per_page=6)
print(f'Page 1: {len(page[\"images\"])} images, {page[\"total_pages\"]} total pages')
"
```
  </verify>
  <done>
- ImageLibrary class exists with discover_images, get_shuffled_images, get_paginated_images methods
- Config has image_library_path, images_per_page, image_cache_ttl settings
- Same seed produces same shuffle order
- Pagination returns correct page structure
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Images API Router</name>
  <files>the55/app/routers/images.py</files>
  <action>
Replace `app/routers/images.py` with enhanced version supporting pagination and seed:

```python
"""
Images API router - serves paginated image list with session-seeded randomization.

v2.1: Updated for auto-discovery and 200+ image support.
"""

from typing import Optional

from fastapi import APIRouter, Query

from app.services.images import get_image_library

router = APIRouter(prefix="/api", tags=["images"])


@router.get("/images")
async def list_images(
    page: int = Query(1, ge=1, description="Page number (1-indexed)"),
    per_page: int = Query(20, ge=1, le=100, description="Images per page"),
    seed: Optional[int] = Query(None, description="Random seed for consistent ordering (typically session_id)")
):
    """
    Return paginated list of available images.

    When seed is provided, images are shuffled in a deterministic order.
    Same seed always produces same order, enabling consistent navigation.

    Args:
        page: Page number (1-indexed, default 1)
        per_page: Images per page (default 20, max 100)
        seed: Random seed for shuffling (optional, typically session_id)

    Returns:
        {
            images: [{id, filename, url}, ...],
            total: int,
            page: int,
            per_page: int,
            total_pages: int
        }
    """
    library = get_image_library()

    if seed is not None:
        return library.get_paginated_images(seed, page, per_page)
    else:
        # No seed = return in discovery order (sorted by filename)
        images = library.discover_images()
        total = len(images)
        total_pages = (total + per_page - 1) // per_page if total > 0 else 1
        page = max(1, min(page, total_pages))
        start = (page - 1) * per_page
        end = start + per_page

        return {
            "images": images[start:end],
            "total": total,
            "page": page,
            "per_page": per_page,
            "total_pages": total_pages
        }


@router.get("/images/count")
async def image_count():
    """Return total number of available images."""
    library = get_image_library()
    return {"count": library.count}
```

Import the router in `app/routers/__init__.py` if not already done (should be existing).
  </action>
  <verify>
```bash
cd /var/www/the55
# Start the app in background for testing
python -c "
import httpx
import asyncio

async def test():
    async with httpx.AsyncClient(base_url='http://localhost:8055') as client:
        # Test default (no seed)
        r = await client.get('/api/images')
        data = r.json()
        print(f'Default: {data[\"total\"]} images, page {data[\"page\"]}/{data[\"total_pages\"]}')

        # Test with seed
        r = await client.get('/api/images?seed=12345&page=1&per_page=6')
        data1 = r.json()

        r = await client.get('/api/images?seed=12345&page=1&per_page=6')
        data2 = r.json()

        # Same seed should give same order
        ids1 = [img['id'] for img in data1['images']]
        ids2 = [img['id'] for img in data2['images']]
        assert ids1 == ids2, 'Seed not producing consistent order!'
        print(f'Seeded (12345): First 6 images: {ids1}')

        # Different seed should give different order
        r = await client.get('/api/images?seed=99999&page=1&per_page=6')
        data3 = r.json()
        ids3 = [img['id'] for img in data3['images']]
        print(f'Seeded (99999): First 6 images: {ids3}')

        # Count endpoint
        r = await client.get('/api/images/count')
        print(f'Count: {r.json()}')

# Note: Run this when server is running
print('API endpoints ready for manual testing with curl or browser')
"

# Test with curl (when server is running)
echo "Test commands (run when server is up):"
echo "curl http://localhost:8055/api/images"
echo "curl http://localhost:8055/api/images?seed=12345"
echo "curl http://localhost:8055/api/images/count"
```
  </verify>
  <done>
- GET /api/images returns paginated images with total, page, per_page, total_pages
- GET /api/images?seed=123 returns consistent shuffled order
- GET /api/images/count returns total image count
- Same seed always produces same order
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Participant Router for Dynamic Images</name>
  <files>the55/app/routers/participant.py</files>
  <action>
Update `app/routers/participant.py` to use ImageLibrary for generating image pages with session-seeded randomization.

Find the respond page handler (around line 332-348) and update:

1. Add import at top of file:
```python
from app.services.images import get_image_library
from app.config import get_settings
```

2. Replace the hardcoded image pagination logic (lines ~332-336):

```python
# OLD CODE:
# image_pages = []
# for start in range(1, 56, 6):
#     end = min(start + 5, 55)
#     image_pages.append((start, end))

# NEW CODE:
settings = get_settings()
library = get_image_library()
per_page = settings.images_per_page  # Default 20

# Get shuffled images using session ID as seed
shuffled_images = library.get_shuffled_images(seed=session.id)
total_images = len(shuffled_images)

# Generate page ranges based on image indices (0-indexed)
image_pages = []
for start_idx in range(0, total_images, per_page):
    end_idx = min(start_idx + per_page - 1, total_images - 1)
    image_pages.append((start_idx, end_idx))
```

3. Update the template context to include shuffled_images:
```python
return templates.TemplateResponse(
    "participant/respond.html",
    {
        "request": request,
        "team": team,
        "session": session,
        "member": member,
        "existing_response": existing_response,
        "image_pages": image_pages,
        "images": shuffled_images,  # NEW: pass full shuffled list
        "total_images": total_images,  # NEW: total count
        "per_page": per_page,  # NEW: images per page
    }
)
```

Note: The template will need updates in Phase 19 to use the new images list. For now, maintain backward compatibility by also generating old-style ranges if needed for the current 55-image set.

For backward compatibility during transition, add fallback logic:
```python
# Backward compatibility: if using old 55-image set, keep numbered approach
if total_images == 55 and all(img.id.isdigit() for img in shuffled_images[:5]):
    # Use old numbered approach for current template
    shuffled_numbers = [int(img.id) for img in shuffled_images]
    image_pages = []
    for start_idx in range(0, 55, 6):
        end_idx = min(start_idx + 5, 54)
        # Page contains these image numbers
        page_numbers = shuffled_numbers[start_idx:end_idx + 1]
        image_pages.append((start_idx, end_idx, page_numbers))
```
  </action>
  <verify>
```bash
cd /var/www/the55
python -c "
from app.services.images import get_image_library
from app.config import get_settings

settings = get_settings()
library = get_image_library()

# Simulate what participant router will do
session_id = 42
shuffled = library.get_shuffled_images(seed=session_id)
print(f'Total images: {len(shuffled)}')
print(f'First 6: {[img.id for img in shuffled[:6]]}')

# Same session should get same order
shuffled2 = library.get_shuffled_images(seed=session_id)
assert [img.id for img in shuffled] == [img.id for img in shuffled2]
print('Session consistency: OK')

# Different session should get different order
shuffled3 = library.get_shuffled_images(seed=session_id + 1)
if shuffled[:6] != shuffled3[:6]:
    print('Different sessions get different order: OK')
"
```
  </verify>
  <done>
- Participant router imports and uses ImageLibrary
- Image order is seeded by session.id for consistency
- All participants in same session see same image order
- Different sessions see different random orders
  </done>
</task>

</tasks>

<verification>
1. Run unit tests for ImageLibrary:
```bash
cd /var/www/the55
python -m pytest tests/ -v -k image 2>/dev/null || echo "No existing image tests"
```

2. Test API endpoints manually:
```bash
# With server running:
curl http://localhost:8055/api/images | jq '.total, .page, .total_pages'
curl http://localhost:8055/api/images?seed=123 | jq '.images[:3]'
curl http://localhost:8055/api/images/count
```

3. Verify shuffle consistency:
```bash
# Same seed = same order
curl -s "http://localhost:8055/api/images?seed=42&per_page=5" | jq '[.images[].id]'
curl -s "http://localhost:8055/api/images?seed=42&per_page=5" | jq '[.images[].id]'
# Should be identical
```

4. Verify no code changes needed for new images:
```bash
# Add a test image
touch /var/www/the55/app/static/images/library/test-image.svg
curl http://localhost:8055/api/images/count  # Should increase
rm /var/www/the55/app/static/images/library/test-image.svg
curl http://localhost:8055/api/images/count  # Should decrease
```
</verification>

<success_criteria>
- [ ] LIB-01: Images auto-discovered from directory (no hardcoded list)
- [ ] LIB-02: Random order seeded by session ID (consistent within session)
- [ ] LIB-03: Adding/removing images requires no code changes
- [ ] API returns paginated response with total, page, per_page, total_pages
- [ ] Same seed always produces same shuffle order
- [ ] Config settings for image_library_path, images_per_page, image_cache_ttl
</success_criteria>

<output>
After completion, create `.planning/phases/18-image-library-foundation/18-01-SUMMARY.md`
</output>
